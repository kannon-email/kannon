# PostgreSQL Repository Implementation Guide

This guide documents the repository implementation pattern used in Kannon. For a complete working example, see the API Keys implementation in `internal/apikeys/` and `internal/db/key_repo.go`.

## Overview

Kannon follows a domain-driven repository pattern with clear separation between:

- **Domain packages** (`internal/*/`) - Define interfaces, domain models, and business logic
- **Database layer** (`internal/db/`) - Implements repositories using sqlc-generated code
- **Migrations** (`db/migrations/`) - Database schema managed with dbmate

## Directory Structure

```
kannon/
├── db/
│   ├── migrations/          # Database migrations (dbmate)
│   └── schema.sql          # Full schema dump
├── internal/
│   ├── apikeys/            # Example domain package
│   │   ├── repo.go        # Repository interface
│   │   ├── key.go         # Domain model with LoadEntity pattern
│   │   └── repospec.go    # Specification tests
│   └── db/                 # Database implementation layer
│       ├── apikeys.sql     # SQL queries for sqlc
│       ├── key_repo.go     # Repository implementation
│       └── *.sql.go        # Generated by sqlc
└── sqlc.yaml              # sqlc configuration
```

## Implementation Steps

### 1. Database Schema

Create migration with `dbmate`:

```bash
dbmate new create_your_table
```

See: `db/migrations/20260104120000_add_api_keys.sql`

### 2. SQL Queries

Define queries in `internal/db/your_table.sql` with sqlc annotations:

```sql
-- name: CreateAPIKey :one
INSERT INTO api_keys (id, domain, key, name, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING *;

-- name: GetAPIKeyByIDForUpdate :one
SELECT * FROM api_keys
WHERE id = $1 AND domain = $2
FOR UPDATE;  -- Critical for concurrent updates
```

**See:** `internal/db/apikeys.sql` for complete examples

### 3. Domain Model with LoadEntity

Define your domain model with a `LoadEntity` function for repository use:

```go
// NewEntity creates a new entity (for business logic)
func NewAPIKey(domain, name string, expiresAt *time.Time) (*APIKey, error) {
    // Validation, ID generation, timestamp assignment
    // ...
}

// LoadEntityParams contains all fields from database
type LoadAPIKeyParams struct {
    ID        ID
    Key       string
    // ... all database fields
}

// LoadEntity creates entity from stored data (for repository)
func LoadAPIKey(p LoadAPIKeyParams) *APIKey {
    return &APIKey{
        id:    p.ID,
        key:   p.Key,
        // ... assign all fields directly
    }
}
```

**See:** `internal/apikeys/key.go:122-146`

### 4. Repository Interface

Define interface in domain package:

```go
type Repository interface {
    Create(ctx context.Context, entity *Entity) error
    Update(ctx context.Context, ref Ref, updateFn UpdateFunc) (*Entity, error)
    GetByID(ctx context.Context, ref Ref) (*Entity, error)
    List(ctx context.Context, filters Filters, page Pagination) ([]*Entity, error)
}
```

**See:** `internal/apikeys/repo.go`

### 5. Repository Implementation

Implement in `internal/db/`:

```go
type entityRepository struct {
    q    *Queries      // sqlc generated queries
    pool *pgxpool.Pool // for transactions
}

func NewEntityRepository(q *Queries, pool *pgxpool.Pool) domain.Repository {
    return &entityRepository{q: q, pool: pool}
}
```

**See:** `internal/db/key_repo.go`

## Quick Reference

### Transaction Pattern

```go
func (r *entityRepository) Update(ctx context.Context, ref domain.Ref, updateFn domain.UpdateFunc) (*domain.Entity, error) {
    // 1. Begin transaction
    tx, err := r.pool.BeginTx(ctx, pgx.TxOptions{})
    if err != nil {
        return nil, err
    }
    defer tx.Rollback(ctx)  // Always defer rollback

    // 2. Create transactional queries
    txq := r.q.WithTx(tx)

    // 3. Get with row lock
    row, err := txq.GetEntityForUpdate(ctx, params)

    // 4. Convert to domain model using LoadEntity
    entity := domain.LoadEntity(domain.LoadEntityParams{
        ID:   domain.ID(row.ID),
        Name: row.Name,
        // ... map all fields
    })

    // 5. Apply business logic
    if err := updateFn(entity); err != nil {
        return nil, err  // Transaction auto-rolls back
    }

    // 6. Persist changes
    _, err = txq.UpdateEntity(ctx, updateParams)

    // 7. Commit
    if err := tx.Commit(ctx); err != nil {
        return nil, err
    }

    return entity, nil
}
```

**See:** `internal/db/key_repo.go:43-106`

### Error Handling

```go
row, err := r.q.GetEntityByID(ctx, params)
if err != nil {
    if errors.Is(err, pgx.ErrNoRows) {
        return nil, domain.ErrEntityNotFound  // Convert to domain error
    }
    return nil, err
}
```

### sqlc Query Annotations

- `:one` - Returns single row
- `:many` - Returns multiple rows
- `:exec` - No return value

### Commands

```bash
# Create migration
dbmate new migration_name

# Generate sqlc code
make generate-db  # or: sqlc generate

# Run tests
make test
```

## Testing

### Specification Testing Pattern

Define reusable specification tests in your domain package:

```go
// domain/repospec.go
type RepoTestHelper struct {
    CreateDomain func(t *testing.T) string
    CleanDB      func(t *testing.T)
}

func RunRepoSpec(t *testing.T, repo Repository, helper RepoTestHelper) {
    t.Run("Create", func(t *testing.T) { /* ... */ })
    t.Run("Update", func(t *testing.T) { /* ... */ })
    // ... more test groups
}
```

**See:** `internal/apikeys/repospec.go`

### Test Setup

```go
// internal/db/db_test.go
var db *pgxpool.Pool
var q *Queries

func TestMain(m *testing.M) {
    db, purge, err = tests.TestPostgresInit(schema.Schema)
    q = New(db)

    code := m.Run()
    purge()
    os.Exit(code)
}
```

**See:** `internal/db/db_test.go`

## Implementation Checklist

When adding a new repository:

- [ ] Create migration with `dbmate new`
- [ ] Define SQL queries in `internal/db/your_table.sql`
- [ ] Add `LoadEntity` function to domain model
- [ ] Define repository interface in domain package
- [ ] Implement repository in `internal/db/your_repo.go`
- [ ] Use transactions for all write operations
- [ ] Include `FOR UPDATE` queries for concurrent updates
- [ ] Convert database errors to domain errors
- [ ] Create specification tests in domain package
- [ ] Run `make generate-db` to generate sqlc code
- [ ] Run `make test` to verify implementation

## Key Principles

1. **Domain-driven design** - Interfaces in domain packages, implementations in db package
2. **Type safety** - sqlc generates type-safe code from SQL
3. **Transaction safety** - All writes wrapped in transactions using `WithTx()`
4. **Concurrency** - Use `FOR UPDATE` to prevent race conditions
5. **Error translation** - Convert `pgx.ErrNoRows` to domain errors
6. **Clean separation** - Use `LoadEntity` to distinguish creation from loading
7. **Testability** - Specification tests validate any implementation

## References

- **Complete example:** `internal/apikeys/` + `internal/db/key_repo.go`
- **sqlc documentation:** https://docs.sqlc.dev/
- **dbmate documentation:** https://github.com/amacneil/dbmate
- **pgx documentation:** https://github.com/jackc/pgx
