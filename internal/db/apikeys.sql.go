// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: apikeys.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAPIKeysByDomain = `-- name: CountAPIKeysByDomain :one
SELECT COUNT(*)
FROM api_keys
WHERE domain = $1
    AND (CASE WHEN $2::boolean THEN is_active = TRUE ELSE TRUE END)
`

type CountAPIKeysByDomainParams struct {
	Domain  string
	Column2 bool
}

func (q *Queries) CountAPIKeysByDomain(ctx context.Context, arg CountAPIKeysByDomainParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAPIKeysByDomain, arg.Domain, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (id, domain, key_hash, key_prefix, name, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
`

type CreateAPIKeyParams struct {
	ID        string
	Domain    string
	KeyHash   string
	KeyPrefix string
	Name      string
	ExpiresAt pgtype.Timestamp
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, createAPIKey,
		arg.ID,
		arg.Domain,
		arg.KeyHash,
		arg.KeyPrefix,
		arg.Name,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.KeyHash,
		&i.KeyPrefix,
	)
	return i, err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
FROM api_keys
WHERE key_hash = $1 AND domain = $2
`

type GetAPIKeyByHashParams struct {
	KeyHash string
	Domain  string
}

func (q *Queries) GetAPIKeyByHash(ctx context.Context, arg GetAPIKeyByHashParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByHash, arg.KeyHash, arg.Domain)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.KeyHash,
		&i.KeyPrefix,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
FROM api_keys
WHERE id = $1 AND domain = $2
`

type GetAPIKeyByIDParams struct {
	ID     string
	Domain string
}

func (q *Queries) GetAPIKeyByID(ctx context.Context, arg GetAPIKeyByIDParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByID, arg.ID, arg.Domain)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.KeyHash,
		&i.KeyPrefix,
	)
	return i, err
}

const getAPIKeyByIDForUpdate = `-- name: GetAPIKeyByIDForUpdate :one
SELECT id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
FROM api_keys
WHERE id = $1 AND domain = $2
FOR UPDATE
`

type GetAPIKeyByIDForUpdateParams struct {
	ID     string
	Domain string
}

func (q *Queries) GetAPIKeyByIDForUpdate(ctx context.Context, arg GetAPIKeyByIDForUpdateParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByIDForUpdate, arg.ID, arg.Domain)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.KeyHash,
		&i.KeyPrefix,
	)
	return i, err
}

const listAPIKeysByDomain = `-- name: ListAPIKeysByDomain :many
SELECT id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
FROM api_keys
WHERE domain = $1
    AND (CASE WHEN $2::boolean THEN is_active = TRUE ELSE TRUE END)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAPIKeysByDomainParams struct {
	Domain  string
	Column2 bool
	Limit   int32
	Offset  int32
}

func (q *Queries) ListAPIKeysByDomain(ctx context.Context, arg ListAPIKeysByDomainParams) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listAPIKeysByDomain,
		arg.Domain,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.DeactivatedAt,
			&i.KeyHash,
			&i.KeyPrefix,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAPIKey = `-- name: UpdateAPIKey :one
UPDATE api_keys
SET name = $3,
    expires_at = $4,
    is_active = $5,
    deactivated_at = $6
WHERE id = $1 AND domain = $2
RETURNING id, name, domain, created_at, expires_at, is_active, deactivated_at, key_hash, key_prefix
`

type UpdateAPIKeyParams struct {
	ID            string
	Domain        string
	Name          string
	ExpiresAt     pgtype.Timestamp
	IsActive      bool
	DeactivatedAt pgtype.Timestamp
}

func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, updateAPIKey,
		arg.ID,
		arg.Domain,
		arg.Name,
		arg.ExpiresAt,
		arg.IsActive,
		arg.DeactivatedAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.DeactivatedAt,
		&i.KeyHash,
		&i.KeyPrefix,
	)
	return i, err
}
