// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: statistics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pbtypes "github.com/ludusrusso/kannon/proto/kannon/stats/types"
)

const countQueryStats = `-- name: CountQueryStats :one
SELECT COUNT(*) FROM stats 
WHERE domain = $1 
AND timestamp BETWEEN $2 AND $3
`

type CountQueryStatsParams struct {
	Domain string
	Start  pgtype.Timestamp
	Stop   pgtype.Timestamp
}

func (q *Queries) CountQueryStats(ctx context.Context, arg CountQueryStatsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQueryStats, arg.Domain, arg.Start, arg.Stop)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertStat = `-- name: InsertStat :exec
INSERT INTO stats (email, message_id, type, timestamp, domain, data) VALUES  ($1, $2, $3, $4, $5, $6)
`

type InsertStatParams struct {
	Email     string
	MessageID string
	Type      StatsType
	Timestamp pgtype.Timestamp
	Domain    string
	Data      *pbtypes.StatsData
}

func (q *Queries) InsertStat(ctx context.Context, arg InsertStatParams) error {
	_, err := q.db.Exec(ctx, insertStat,
		arg.Email,
		arg.MessageID,
		arg.Type,
		arg.Timestamp,
		arg.Domain,
		arg.Data,
	)
	return err
}

const queryStats = `-- name: QueryStats :many
SELECT id, type, email, message_id, domain, timestamp, data FROM stats 
WHERE domain = $1 
AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp DESC
LIMIT $5 OFFSET $4
`

type QueryStatsParams struct {
	Domain string
	Start  pgtype.Timestamp
	Stop   pgtype.Timestamp
	Skip   int32
	Take   int32
}

func (q *Queries) QueryStats(ctx context.Context, arg QueryStatsParams) ([]Stat, error) {
	rows, err := q.db.Query(ctx, queryStats,
		arg.Domain,
		arg.Start,
		arg.Stop,
		arg.Skip,
		arg.Take,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stat
	for rows.Next() {
		var i Stat
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.MessageID,
			&i.Domain,
			&i.Timestamp,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryStatsTimeline = `-- name: QueryStatsTimeline :many
SELECT 
	type, 
	COUNT(*) as count, 
	date_trunc('hour', timestamp)::TIMESTAMP AS ts 
FROM stats 
WHERE domain = $1
AND timestamp BETWEEN $2 AND $3
GROUP BY type, ts
ORDER BY ts DESC, type
`

type QueryStatsTimelineParams struct {
	Domain string
	Start  pgtype.Timestamp
	Stop   pgtype.Timestamp
}

type QueryStatsTimelineRow struct {
	Type  StatsType
	Count int64
	Ts    pgtype.Timestamp
}

func (q *Queries) QueryStatsTimeline(ctx context.Context, arg QueryStatsTimelineParams) ([]QueryStatsTimelineRow, error) {
	rows, err := q.db.Query(ctx, queryStatsTimeline, arg.Domain, arg.Start, arg.Stop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryStatsTimelineRow
	for rows.Next() {
		var i QueryStatsTimelineRow
		if err := rows.Scan(&i.Type, &i.Count, &i.Ts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
