// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: aggregated_stats.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const incrementAggregatedStat = `-- name: IncrementAggregatedStat :exec
INSERT INTO aggregated_stats (domain, timestamp, type, count)
VALUES ($1, $2, $3, 1)
ON CONFLICT (domain, timestamp, type)
DO UPDATE SET count = aggregated_stats.count + 1
`

type IncrementAggregatedStatParams struct {
	Domain    string
	Timestamp pgtype.Timestamp
	Type      StatsType
}

func (q *Queries) IncrementAggregatedStat(ctx context.Context, arg IncrementAggregatedStatParams) error {
	_, err := q.db.Exec(ctx, incrementAggregatedStat, arg.Domain, arg.Timestamp, arg.Type)
	return err
}

const queryAggregatedStats = `-- name: QueryAggregatedStats :many
SELECT domain, timestamp, type, count FROM aggregated_stats
WHERE domain = $1
AND timestamp >= $2 AND timestamp < $3
ORDER BY timestamp ASC, type
`

type QueryAggregatedStatsParams struct {
	Domain string
	Start  pgtype.Timestamp
	Stop   pgtype.Timestamp
}

func (q *Queries) QueryAggregatedStats(ctx context.Context, arg QueryAggregatedStatsParams) ([]AggregatedStat, error) {
	rows, err := q.db.Query(ctx, queryAggregatedStats, arg.Domain, arg.Start, arg.Stop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggregatedStat
	for rows.Next() {
		var i AggregatedStat
		if err := rows.Scan(
			&i.Domain,
			&i.Timestamp,
			&i.Type,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
